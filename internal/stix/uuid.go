package stix

import (
	"crypto/rand"
	"crypto/sha1"
	"fmt"
)

var (
	// nsSTIX is the byte representation of the STIX UUIDv5 namespace:
	// {00abedb4-aa42-466c-9c01-fed23315a9b7}
	nsSTIX = [16]byte{
		0x00, 0xab, 0xed, 0xb4,
		0xaa, 0x42,
		0x46, 0x6c,
		0x9c, 0x01,
		0xfe, 0xd2, 0x33, 0x15, 0xa9, 0xb7,
	}
)

// NewID returns a new random unique identifier for a STIX Object. Identifiers
// follow the form `objectType--UUID` where `objectType` is the exact value
// from the `type` property of the object and where `UUID` is an RFC
// 4122-compliant UUID. Random identifiers use UUIDv4.
func NewID(objectType string) string {
	return objectType + "--" + newUUIDv4()
}

// DeterministicID returns a deterministic unique identifier for a STIX Object.
// Identifiers follow the form `objectType--UUID` where `objectType` is the
// exact value from the `type` property of the object and where `UUID` is an RFC
// 4122-compliant UUID. Deterministic identifiers use UUIDv5 with the STIX
// namespace and select properties represented in JSON.
func DeterministicID(objectType string, jsonValues string) string {
	return objectType + "--" + newUUIDv5(nsSTIX, jsonValues)
}

// newUUIDv5 returns a string representation of a Universally Unique Identifier
// (UUID) RFC 4122 version 5 value. Version 5 UUIDs are a SHA-1 hash of a
// namespace identifier and a name.
func newUUIDv5(ns [16]byte, name string) string {
	// A version 5 UUID is generated by hashing a namespace identifier (itself,
	// a UUID) and a name (value) using SHA-1. Then specific bits are
	// overwritten to indicate version 5 and the variant (the format of the
	// UUID).

	// As per STIX 2.1, STIX Cyber-observable Objects using deterministic
	// identifiers should use UUIDv5 and the STIX 2.1 namespace:
	// {00abedb4-aa42-466c-9c01-fed23315a9b7}. The value of the name portion
	// should be the list of "ID Contributing Properties" defined for the SCO
	// and their values and represented as a JSON object. Example for IPv4
	// Address Object: {"value":"127.0.0.1"}

	// STIX Domain Objects may use UUIDv5 for the UUID portion of the
	// identifier, but must not use the STIX namespace.

	// Get the SHA-1 hash of `namespace` + `name`.
	h := sha1.New()
	_, _ = h.Write(ns[:])
	_, _ = h.Write([]byte(name))

	// Use only the first 16-bytes of the hash.
	b := h.Sum(nil)[:16]

	// Overwrite the version bits with 0b0101 (UUID version 5).
	b[6] = (b[6] & 0x0f) | 0x50

	// Overwrite the variant bits with 0b10.
	b[8] = (b[8] & 0x3f) | 0x80

	// Return as UUID string representation.
	return fmt.Sprintf("%08x-%04x-%04x-%04x-%012x", b[0:4], b[4:6], b[6:8], b[8:10], b[10:])
}

// newUUIDv4 returns a string representation of a Universally Unique Identifier
// (UUID) RFC 4122 version 4 value. Version 4 UUIDs are random values.
func newUUIDv4() string {
	// A version 4 UUID is randomly generated. Then specific bits are
	// overwritten to indicate version 4 and the variant (the format of the
	// UUID).

	// Get 16 random bytes. crypto/rand.Read is guaranteed to never return an
	// error (as of Go 1.24).
	var b = [16]byte{}
	rand.Read(b[:])

	// Overwrite the version bits with 0b0100 (UUID version 4).
	b[6] = (b[6] & 0x0f) | 0x40

	// Overwrite the variant bits with 0b10.
	b[8] = (b[8] & 0x3f) | 0x80

	// Return as UUID string representation.
	return fmt.Sprintf("%08x-%04x-%04x-%04x-%012x", b[0:4], b[4:6], b[6:8], b[8:10], b[10:])
}
