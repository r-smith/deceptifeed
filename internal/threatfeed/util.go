package threatfeed

import (
	"crypto/rand"
	"crypto/sha1"
	"fmt"
	"io"
)

// namespace is a UUID version 5 namespace.
type namespace int

const (
	// nsDNS represents the UUIDv5 pre-defined `ns:DNS` namespace.
	nsDNS namespace = iota

	// nsSTIX represents the UUIDv5 namespace used by the STIX specification.
	nsSTIX
)

// newUUIDv5 returns a string representation of a Universally Unique Identifier
// (UUID) RFC 4122 version 5 value. Version 5 UUIDs are a SHA-1 hash of a
// namespace identifier and a name.
func newUUIDv5(ns namespace, name string) string {
	// A version 5 UUID is generated by hashing a namespace identifier (itself,
	// a UUID) and a name (value) using SHA-1. Then specific bits are
	// overwritten to indicate version 5 and the variant (the format of the
	// UUID).

	// As per STIX 2.1, STIX Cyber-observable Objects using deterministic
	// identifiers should use UUIDv5 and the STIX 2.1 namespace:
	// {00abedb4-aa42-466c-9c01-fed23315a9b7}. The value of the name portion
	// should be the list of "ID Contributing Properties" defined for the SCO
	// and their values and represented as a JSON object. Example for IPv4
	// Address Object: {"value":"127.0.0.1"}

	// STIX Domain Objects may use UUIDv5 for the UUID portion of the
	// identifier, but must not use the STIX namespace.

	var n = [16]byte{}
	switch ns {
	case nsDNS:
		// Byte representation of the pre-defined UUIDv5 DNS namespace:
		// {6ba7b810-9dad-11d1-80b4-00c04fd430c8}
		n = [16]byte{
			0x6b, 0xa7, 0xb8, 0x10,
			0x9d, 0xad,
			0x11, 0xd1,
			0x80, 0xb4,
			0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8,
		}
	case nsSTIX:
		// Byte representation of the STIX Cyber-observable Objects namespace:
		// {00abedb4-aa42-466c-9c01-fed23315a9b7}
		n = [16]byte{
			0x00, 0xab, 0xed, 0xb4,
			0xaa, 0x42,
			0x46, 0x6c,
			0x9c, 0x01,
			0xfe, 0xd2, 0x33, 0x15, 0xa9, 0xb7,
		}
	}

	// Get the SHA-1 hash of `namespace` + `name`.
	h := sha1.New()
	_, _ = h.Write(n[:])
	_, _ = h.Write([]byte(name))

	// Use only the first 16-bytes of the hash.
	b := h.Sum(nil)[:16]

	// Overwrite the version bits with 0b0101 (UUID version 5).
	b[6] = (b[6] & 0x0f) | 0x50

	// Overwrite the variant bits with 0b10.
	b[8] = (b[8] & 0x3f) | 0x80

	// Return as UUID string representation.
	return fmt.Sprintf("%08x-%04x-%04x-%04x-%012x", b[0:4], b[4:6], b[6:8], b[8:10], b[10:])
}

// newUUIDv4 returns a string representation of a Universally Unique Identifier
// (UUID) RFC 4122 version 4 value. Version 4 UUIDs are random values.
func newUUIDv4() string {
	// A version 4 UUID is randomly generated. Then specific bits are
	// overwritten to indicate version 4 and the variant (the format of the
	// UUID).

	// Get 16 random bytes.
	var b = [16]byte{}
	io.ReadFull(rand.Reader, b[:])

	// Overwrite the version bits with 0b0100 (UUID version 4).
	b[6] = (b[6] & 0x0f) | 0x40

	// Overwrite the variant bits with 0b10.
	b[8] = (b[8] & 0x3f) | 0x80

	// Return as UUID string representation.
	return fmt.Sprintf("%08x-%04x-%04x-%04x-%012x", b[0:4], b[4:6], b[6:8], b[8:10], b[10:])
}
